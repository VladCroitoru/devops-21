\section{Process' perspective}
\subsection{How do you interact as developers?}
There were a few channels of communication. Every monday, after the lecture we would have a "traditional" standup-meeting where each member could lay out potential issues.
\\\\
After the task of the finished week were discussed, and dealt with, we would turn our focus on the coming week, and allocate which tasks should be solved by next monday. More on this later.
\\\\
Since the course was organized with a lecture a week, and corresponding deadlines for the work, we would also often have a less formal standup on Sundays, in the case that certain tasks were lingering, or needed discussion.
\\\\
By attempting to keep our tasks small and keeping up frequent communication on teams, we tried to keep a steady value stream going throughout the week. Thus we were also hoping to decrease the amount of lead time for tasks. This was however not always achievable because of external time pressures, and much of the processing time was often placed at the end of the week.
\\\\
It's probably worth noting that we never met physically during working together, which increased the importancy of frequent communications on teams, and clear communication regarding which times one would be available.
\subsubsection{How is the team organized?}
\subsection{Stages and tools}
\subsection{Organization of repositories}
\subsection{Applied branching strategy}
In week 2 we discussed what branching strategy we should use. We quickly narrowed the field of possible strategies to two - Git Flow and GitHub Flow, since these were the two strategies most people had experience with within the group. 
\\\\
Git Flow is a strategy where the main branch is used for released code e.g. stable releases. A development branch is merged out from the main branch, which is used to branch out feature branches where actual new work is done. New features are then merged back into the development branch. Once the team is ready to make a release, the development branch is merged into a release branch, then into main and released.
\\\\
GitHub Flow is more simple than Git Flow since it does not have release and development branches. New features are instead merged out from the main branch, and back into the main branch once the feature is done. This will result in that the main branch containing code that is not yet released if deployment is not automatically set up.
\\\\
We initially decided to go with Git Flow, since we would work on features throughout the week, and then create a single release on Sundays. We quickly realized that releasing once a week was not satisfactory for our needs, since we often wanted features to be pushed immediately once ready, and merging back and forth between the main branch and the development branch was cumbersome.
\\\\
By week 7, we decided to change our branching strategy to GitHub Flow due to the addition of static code analysis and the rewrite of API simulation tests from Python to Golang. The motivation for the change in strategy is a move towards Continuous Deployment. Our pipelines now supported a full deployment process from our main branch to our production servers with automatic releases. This means that a Git Flow strategy will only hinder our lead time from user story to production.